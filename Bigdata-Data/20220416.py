from time import time
import numpy as np

# 배열의 크기
# - 같은 값과 같은 수자를 가진 배열이라도 크기가 다르면
#   다른 배열
# - 배열의 연산 및 반복에서 주의 요망
# - 예 : 길이가 5일 1차원 배열, (5, 1) 인 2차원 배열
#        (1, 5)인 2차원 배열
x = np.arange(5)
print(x) # [0 1 2 3 4]

print(x.reshape(1, 5)) # [[0 1 2 3 4]]

print(x.reshape(5, 1))  #[[0]
                        #[1]
                        #[2]
                        #[3]
                        #[4]]]
# [10, 20,30 ,40]
# [50, 60, 70, 80]
# 위와 같은 배열을 float16으로 만드시오.
bb = np.array([[10, 20, 30 , 40], [50, 60, 70, 80]], dtype="float16")
print(bb)
# [[10. 20. 30. 40.]
#  [50. 60. 70. 80.]]

# int16의 같은 행렬을 만드시요.
cc = np.array([[10, 20, 30 , 40], [50, 60, 70, 80]], dtype="int16")
print(cc)
# [[10. 20. 30. 40.]
#  [50. 60. 70. 80.]]

# flatten()을 사용하여 1차원 배열로 변경
bb = bb.flatten() # flatten()은 수정 데이터 불가
print(bb) # [10. 20. 30. 40. 50. 60. 70. 80.]

# cc의 배열을 4 X 2 배열로 만든다.
# reshape() 사용
cc = cc.reshape(4, 2) # cc.reshape(4, -1) -1은 자동
print(cc)
# [[10 20]
#  [30 40]
#  [50 60]
#  [70 80]]

# 전치를 사용하여 번형
cc = cc.T
print(cc)
# [[10 30 50 70]
#  [20 40 60 80]]

# cc와 같은 크기를 가진, 원소를
# 1로만 가지는 행렬 생성 (이름 dd)
dd = np.ones_like(cc)
print(dd) 
# [[1 1 1 1]
#  [1 1 1 1]]

# cc와 같은 크기를 가진, 원소를 
# 0로만 가지는 행렬 생성 (ff)
ff = np.zeros_like(cc)
print(ff)
# [[0 0 0 0]
#  [0 0 0 0]]

# 배열의 연결
# hstack : 행의 수가 같은 배열을 옆으로 연결 (horizontal)
a1 = np.ones((2,3))
print(a1)
# [[1. 1. 1.]
#  [1. 1. 1.]]

a2 = np.zeros((2,3))
print(a2)
# [[0. 0. 0.]
#  [0. 0. 0.]]

a3 = np.stack([a1, a2])
print(a3)
# [[[1. 1. 1.]
#   [1. 1. 1.]]
#  [[0. 0. 0.]
#   [0. 0. 0.]]]

# vstack : 열의 수가 같은 배열을 아래 위로 연결 (vertical)
b1 = np.ones((2,3))
print(b1)
# [[1. 1. 1.]
#  [1. 1. 1.]]

b2 = np.zeros((3,3))
print(b2)
# [[0. 0. 0.]
#  [0. 0. 0.]
#  [0. 0. 0.]]

b3 = np.vstack([b1, b2])
print(b3)
# [[1. 1. 1.]
#  [1. 1. 1.]
#  [0. 0. 0.]
#  [0. 0. 0.]
#  [0. 0. 0.]]

#d dstack : 행과 열이 아닌 깊이 방향으로 배열을 연결
c1 = np.ones((3, 4))
print(c1)
# [[1. 1. 1. 1.]
#  [1. 1. 1. 1.]
#  [1. 1. 1. 1.]]

c2 = np.zeros((3,4))
print(c2)
# [[0. 0. 0. 0.]
#  [0. 0. 0. 0.]
#  [0. 0. 0. 0.]]

c3 = (np.dstack([c1, c2]))
print(c3)
# [[[1. 0.]
#   [1. 0.]
#   [1. 0.]
#   [1. 0.]]

#  [[1. 0.]
#   [1. 0.]
#   [1. 0.]
#   [1. 0.]]

#  [[1. 0.]
#   [1. 0.]
#   [1. 0.]
#   [1. 0.]]]

# stack : 앞의 dstack 메소드의 확장 기능 제공
# axis 인수 (기본 값 0)를 지정하여 지정한 인수로 차원을 확장
# asis = 0 : 위에서 아래로 Data를 합친다는 의미
c = np.stack([c1, c2]) # axis = 0으로 기본 세팅
print(c)
# [[[1. 1. 1. 1.]
#   [1. 1. 1. 1.]
#   [1. 1. 1. 1.]]

#  [[0. 0. 0. 0.]
#   [0. 0. 0. 0.]
#   [0. 0. 0. 0.]]]
print(c.shape)
# (2,3,4)

# axis = 1 : 좌에서 우로 데이터를 합친다는 의미
x = np.stack([c1, c2], axis=1)
print(c)
# [[[1. 1. 1. 1.]
#   [1. 1. 1. 1.]
#   [1. 1. 1. 1.]]

#  [[0. 0. 0. 0.]
#   [0. 0. 0. 0.]
#   [0. 0. 0. 0.]]]
print(c.shape)
# (2, 3, 4)

# tile : 동일한 배열을 반복하여 연결 
a = np.array([[0,1,2], [3,44,5]])
print(np.tile(a, 2))
# [[ 0  1  2  0  1  2]
#  [ 3 44  5  3 44  5]]
print(np.tile(a,(3,2)))
# [[ 0  1  2  0  1  2]
#  [ 3 44  5  3 44  5]
#  [ 0  1  2  0  1  2]
#  [ 3 44  5  3 44  5]
#  [ 0  1  2  0  1  2]
#  [ 3 44  5  3 44  5]]

x = np.arange(1, 10001)
y = np.arange(10001, 20001)

# 셀 메직 명령어
# %time
z = np.zeros_like(x)
print(z)

z = np.zeros_like(x)
for i in range(10000):
    z[i] = x[i] + y[i]

z = x + y

# 백터와 연산
# - Numpy의 배열은 벡터화 연산(vectorized operation)을 지원함
# - 배열간의 연산에서 요소들끼리(element-wise) 연산
# - 일반 연산에서 각 요소에 모두 적용
a = np.array([1, 2, 3, 4])
b = np.array([4, 5, 6, 7])
print(a + b)
# [5 7 9 11]

print(a == b)
# [False False False False]

print(np.all(a==b))
# False
# all 명령 사용 시 모든 원소가 같은 지 검사한 후
# 결과를 True/False로 변환

# 도은 요소 적용되는 일반 연산
a = np.arange(5)
print(a)
# [0, 1, 2, 3, 4]

print(np.exp(a))
# [ 1.          2.71828183  7.3890561  20.08553692 54.59815003]

print(10 ** a)
# [    1    10   100  1000 10000]

print(np.log(a + 1))
# [0.         0.69314718 1.09861229 1.38629436 1.60943791]

print(100 * a)
# [  0 100 200 300 400]

# 브로드캐스팅
# - 서로 다른 크기의 두 배열의 사칙연산을 자동으로 수행하는 기능
# - 크기가 큰 배열에 맞추어 크기가 작은 배열을 확장하여 수행
x = np.arange(5)
print(x)
# [0, 1, 2, 3, 4]

y = np.ones_like(x)
print(y)
# [1 1 1 1 1]

print(x + y)
# [1 2 3 4 5]

print(x + 1)
# [1 2 3 4 5]

x = np.vstack([range(7)[i:i + 3] for i in range(5)])
print(x)
# [[0 1 2]
#  [1 2 3]
#  [2 3 4]
#  [3 4 5]
#  [4 5 6]]

y = np.arange(5)[:, np.newaxis]
print(y)
# [[0]
#  [1]
#  [2]
#  [3]
#  [4]]

print(x + y)
# [[ 0  1  2]
#  [ 2  3  4]
#  [ 4  5  6]
#  [ 6  7  8]
#  [ 8  9 10]]


